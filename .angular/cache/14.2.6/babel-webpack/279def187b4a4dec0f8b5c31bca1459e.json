{"ast":null,"code":"/**\n * Utilites to manipulate the position of elements relative to other elements\n */\nvar _a;\n\nexport var PLACEMENTS;\n\n(function (PLACEMENTS) {\n  PLACEMENTS[\"LEFT\"] = \"left\";\n  PLACEMENTS[\"RIGHT\"] = \"right\";\n  PLACEMENTS[\"TOP\"] = \"top\";\n  PLACEMENTS[\"BOTTOM\"] = \"bottom\";\n})(PLACEMENTS || (PLACEMENTS = {}));\n\nexport var defaultPositions = (_a = {}, _a[PLACEMENTS.LEFT] = function (referenceOffset, target, referenceRect) {\n  return {\n    top: referenceOffset.top - Math.round(target.offsetHeight / 2) + Math.round(referenceRect.height / 2),\n    left: Math.round(referenceOffset.left - target.offsetWidth)\n  };\n}, _a[PLACEMENTS.RIGHT] = function (referenceOffset, target, referenceRect) {\n  return {\n    top: referenceOffset.top - Math.round(target.offsetHeight / 2) + Math.round(referenceRect.height / 2),\n    left: Math.round(referenceOffset.left + referenceRect.width)\n  };\n}, _a[PLACEMENTS.TOP] = function (referenceOffset, target, referenceRect) {\n  return {\n    top: Math.round(referenceOffset.top - target.offsetHeight),\n    left: referenceOffset.left - Math.round(target.offsetWidth / 2) + Math.round(referenceRect.width / 2)\n  };\n}, _a[PLACEMENTS.BOTTOM] = function (referenceOffset, target, referenceRect) {\n  return {\n    top: Math.round(referenceOffset.top + referenceRect.height),\n    left: referenceOffset.left - Math.round(target.offsetWidth / 2) + Math.round(referenceRect.width / 2)\n  };\n}, _a);\nvar windowRef = typeof window !== \"undefined\" ? window : {\n  innerHeight: 0,\n  scrollY: 0,\n  innerWidth: 0,\n  scrollX: 0\n};\n\nvar Position =\n/** @class */\nfunction () {\n  function Position(positions) {\n    if (positions === void 0) {\n      positions = {};\n    }\n\n    this.positions = defaultPositions;\n    this.positions = Object.assign({}, defaultPositions, positions);\n  }\n\n  Position.prototype.getRelativeOffset = function (target) {\n    // start with the initial element offsets\n    var offsets = {\n      left: target.offsetLeft,\n      top: target.offsetTop\n    }; // get each static (i.e. not absolute or relative) offsetParent and sum the left/right offsets\n\n    while (target.offsetParent && getComputedStyle(target.offsetParent).position === \"static\") {\n      offsets.left += target.offsetLeft;\n      offsets.top += target.offsetTop;\n      target = target.offsetParent;\n    }\n\n    return offsets;\n  };\n\n  Position.prototype.getAbsoluteOffset = function (target) {\n    var currentNode = target;\n    var margins = {\n      top: 0,\n      left: 0\n    }; // searches for containing elements with additional margins\n\n    while (currentNode.offsetParent) {\n      var computed = getComputedStyle(currentNode.offsetParent); // find static elements with additional margins\n      // since they tend to throw off our positioning\n      // (usually this is just the body)\n\n      if (computed.position === \"static\" && computed.marginLeft && computed.marginTop) {\n        if (parseInt(computed.marginTop, 10)) {\n          margins.top += parseInt(computed.marginTop, 10);\n        }\n\n        if (parseInt(computed.marginLeft, 10)) {\n          margins.left += parseInt(computed.marginLeft, 10);\n        }\n      }\n\n      currentNode = currentNode.offsetParent;\n    }\n\n    var targetRect = target.getBoundingClientRect();\n    var relativeRect = document.body.getBoundingClientRect();\n    return {\n      top: targetRect.top - relativeRect.top + margins.top,\n      left: targetRect.left - relativeRect.left + margins.left\n    };\n  }; // finds the position relative to the `reference` element\n\n\n  Position.prototype.findRelative = function (reference, target, placement) {\n    var referenceOffset = this.getRelativeOffset(reference);\n    var referenceRect = reference.getBoundingClientRect();\n    return this.calculatePosition(referenceOffset, referenceRect, target, placement);\n  };\n\n  Position.prototype.findAbsolute = function (reference, target, placement) {\n    var referenceOffset = this.getAbsoluteOffset(reference);\n    var referenceRect = reference.getBoundingClientRect();\n    return this.calculatePosition(referenceOffset, referenceRect, target, placement);\n  };\n\n  Position.prototype.findPosition = function (reference, target, placement, offsetFunction) {\n    if (offsetFunction === void 0) {\n      offsetFunction = this.getAbsoluteOffset.bind(this);\n    }\n\n    var referenceOffset = offsetFunction(reference);\n    var referenceRect = reference.getBoundingClientRect();\n    return this.calculatePosition(referenceOffset, referenceRect, target, placement);\n  };\n\n  Position.prototype.findPositionAt = function (offset, target, placement) {\n    return this.calculatePosition(offset, {\n      top: 0,\n      left: 0,\n      height: 0,\n      width: 0\n    }, target, placement);\n  };\n  /**\n   * Get the dimensions of an element from an AbsolutePosition and a reference element\n   */\n\n\n  Position.prototype.getPlacementBox = function (target, position) {\n    var targetBottom = target.offsetHeight + position.top;\n    var targetRight = target.offsetWidth + position.left;\n    return {\n      top: position.top,\n      bottom: targetBottom,\n      left: position.left,\n      right: targetRight\n    };\n  };\n\n  Position.prototype.addOffset = function (position, top, left) {\n    if (top === void 0) {\n      top = 0;\n    }\n\n    if (left === void 0) {\n      left = 0;\n    }\n\n    return Object.assign({}, position, {\n      top: position.top + top,\n      left: position.left + left\n    });\n  };\n\n  Position.prototype.setElement = function (element, position) {\n    element.style.top = position.top + \"px\";\n    element.style.left = position.left + \"px\";\n  };\n\n  Position.prototype.findBestPlacement = function (reference, target, placements, containerFunction, positionFunction) {\n    var _this = this;\n\n    if (containerFunction === void 0) {\n      containerFunction = this.defaultContainerFunction.bind(this);\n    }\n\n    if (positionFunction === void 0) {\n      positionFunction = this.findPosition.bind(this);\n    }\n    /**\n     * map over the array of placements and weight them based on the percentage of visible area\n     * where visible area is defined as the area not obscured by the window borders\n     */\n\n\n    var weightedPlacements = placements.map(function (placement) {\n      var pos = positionFunction(reference, target, placement);\n\n      var box = _this.getPlacementBox(target, pos);\n\n      var hiddenHeight = 0;\n      var hiddenWidth = 0;\n      var container = containerFunction(); // the element is exceeding from top or bottom of its container\n\n      if (box.top < container.top) {\n        hiddenHeight = container.top - box.top;\n      } else if (box.bottom > container.height) {\n        hiddenHeight = box.bottom - container.height;\n      } // the element is exceeding from left or right of its container\n\n\n      if (box.left < container.left) {\n        hiddenWidth = container.left - box.left;\n      } else if (box.right > container.width) {\n        hiddenWidth = box.right - container.width;\n      } // if one of the hidden dimensions is 0 but the other is > 0\n      // we want to have a positive area, so setting the null one to 1\n\n\n      if (hiddenHeight && !hiddenWidth) {\n        hiddenWidth = 1;\n      } else if (hiddenWidth && !hiddenHeight) {\n        hiddenHeight = 1;\n      }\n\n      var area = target.offsetHeight * target.offsetWidth;\n      var hiddenArea = hiddenHeight * hiddenWidth; // if visibleArea is 0 it means the element is fully outside container bounds\n      // and visiblePercent will then be 0\n\n      var visibleArea = area - hiddenArea;\n      var visiblePercent = visibleArea / area;\n      return {\n        placement: placement,\n        weight: visiblePercent\n      };\n    }); // sort the placements from best to worst\n\n    weightedPlacements.sort(function (a, b) {\n      return b.weight - a.weight;\n    }); // pick the best!\n\n    return weightedPlacements[0].placement;\n  };\n\n  Position.prototype.findBestPlacementAt = function (offset, target, placements, containerFunction) {\n    var _this = this;\n\n    if (containerFunction === void 0) {\n      containerFunction = this.defaultContainerFunction.bind(this);\n    }\n\n    var positionAt = function (_, target, placement) {\n      return _this.findPositionAt(offset, target, placement);\n    };\n\n    return this.findBestPlacement(null, target, placements, containerFunction, positionAt);\n  };\n\n  Position.prototype.defaultContainerFunction = function () {\n    return {\n      // we go with window here, because that's going to be the simple/common case\n      top: 0,\n      left: 0,\n      height: windowRef.innerHeight,\n      width: windowRef.innerWidth\n    };\n  };\n\n  Position.prototype.calculatePosition = function (referenceOffset, referenceRect, target, placement) {\n    if (this.positions[placement]) {\n      return this.positions[placement](referenceOffset, target, referenceRect);\n    }\n\n    console.error(\"No function found for placement, defaulting to 0,0\");\n    return {\n      left: 0,\n      top: 0\n    };\n  };\n\n  return Position;\n}();\n\nexport { Position };\nexport var position = new Position();\nexport default Position;","map":{"version":3,"names":["_a","PLACEMENTS","defaultPositions","LEFT","referenceOffset","target","referenceRect","top","Math","round","offsetHeight","height","left","offsetWidth","RIGHT","width","TOP","BOTTOM","windowRef","window","innerHeight","scrollY","innerWidth","scrollX","Position","positions","Object","assign","prototype","getRelativeOffset","offsets","offsetLeft","offsetTop","offsetParent","getComputedStyle","position","getAbsoluteOffset","currentNode","margins","computed","marginLeft","marginTop","parseInt","targetRect","getBoundingClientRect","relativeRect","document","body","findRelative","reference","placement","calculatePosition","findAbsolute","findPosition","offsetFunction","bind","findPositionAt","offset","getPlacementBox","targetBottom","targetRight","bottom","right","addOffset","setElement","element","style","findBestPlacement","placements","containerFunction","positionFunction","_this","defaultContainerFunction","weightedPlacements","map","pos","box","hiddenHeight","hiddenWidth","container","area","hiddenArea","visibleArea","visiblePercent","weight","sort","a","b","findBestPlacementAt","positionAt","_","console","error"],"sources":["/Users/TSC/Desktop/Angular-Carbon/carbon-tutorial-angular/node_modules/@carbon/utils-position/index.js"],"sourcesContent":["/**\n * Utilites to manipulate the position of elements relative to other elements\n */\nvar _a;\nexport var PLACEMENTS;\n(function (PLACEMENTS) {\n    PLACEMENTS[\"LEFT\"] = \"left\";\n    PLACEMENTS[\"RIGHT\"] = \"right\";\n    PLACEMENTS[\"TOP\"] = \"top\";\n    PLACEMENTS[\"BOTTOM\"] = \"bottom\";\n})(PLACEMENTS || (PLACEMENTS = {}));\nexport var defaultPositions = (_a = {},\n    _a[PLACEMENTS.LEFT] = function (referenceOffset, target, referenceRect) { return ({\n        top: referenceOffset.top - Math.round(target.offsetHeight / 2) + Math.round(referenceRect.height / 2),\n        left: Math.round(referenceOffset.left - target.offsetWidth)\n    }); },\n    _a[PLACEMENTS.RIGHT] = function (referenceOffset, target, referenceRect) { return ({\n        top: referenceOffset.top - Math.round(target.offsetHeight / 2) + Math.round(referenceRect.height / 2),\n        left: Math.round(referenceOffset.left + referenceRect.width)\n    }); },\n    _a[PLACEMENTS.TOP] = function (referenceOffset, target, referenceRect) { return ({\n        top: Math.round(referenceOffset.top - target.offsetHeight),\n        left: referenceOffset.left - Math.round(target.offsetWidth / 2) + Math.round(referenceRect.width / 2)\n    }); },\n    _a[PLACEMENTS.BOTTOM] = function (referenceOffset, target, referenceRect) { return ({\n        top: Math.round(referenceOffset.top + referenceRect.height),\n        left: referenceOffset.left - Math.round(target.offsetWidth / 2) + Math.round(referenceRect.width / 2)\n    }); },\n    _a);\nvar windowRef = typeof window !== \"undefined\" ? window : {\n    innerHeight: 0,\n    scrollY: 0,\n    innerWidth: 0,\n    scrollX: 0\n};\nvar Position = /** @class */ (function () {\n    function Position(positions) {\n        if (positions === void 0) { positions = {}; }\n        this.positions = defaultPositions;\n        this.positions = Object.assign({}, defaultPositions, positions);\n    }\n    Position.prototype.getRelativeOffset = function (target) {\n        // start with the initial element offsets\n        var offsets = {\n            left: target.offsetLeft,\n            top: target.offsetTop\n        };\n        // get each static (i.e. not absolute or relative) offsetParent and sum the left/right offsets\n        while (target.offsetParent && getComputedStyle(target.offsetParent).position === \"static\") {\n            offsets.left += target.offsetLeft;\n            offsets.top += target.offsetTop;\n            target = target.offsetParent;\n        }\n        return offsets;\n    };\n    Position.prototype.getAbsoluteOffset = function (target) {\n        var currentNode = target;\n        var margins = {\n            top: 0,\n            left: 0\n        };\n        // searches for containing elements with additional margins\n        while (currentNode.offsetParent) {\n            var computed = getComputedStyle(currentNode.offsetParent);\n            // find static elements with additional margins\n            // since they tend to throw off our positioning\n            // (usually this is just the body)\n            if (computed.position === \"static\" &&\n                computed.marginLeft &&\n                computed.marginTop) {\n                if (parseInt(computed.marginTop, 10)) {\n                    margins.top += parseInt(computed.marginTop, 10);\n                }\n                if (parseInt(computed.marginLeft, 10)) {\n                    margins.left += parseInt(computed.marginLeft, 10);\n                }\n            }\n            currentNode = currentNode.offsetParent;\n        }\n        var targetRect = target.getBoundingClientRect();\n        var relativeRect = document.body.getBoundingClientRect();\n        return {\n            top: targetRect.top - relativeRect.top + margins.top,\n            left: targetRect.left - relativeRect.left + margins.left\n        };\n    };\n    // finds the position relative to the `reference` element\n    Position.prototype.findRelative = function (reference, target, placement) {\n        var referenceOffset = this.getRelativeOffset(reference);\n        var referenceRect = reference.getBoundingClientRect();\n        return this.calculatePosition(referenceOffset, referenceRect, target, placement);\n    };\n    Position.prototype.findAbsolute = function (reference, target, placement) {\n        var referenceOffset = this.getAbsoluteOffset(reference);\n        var referenceRect = reference.getBoundingClientRect();\n        return this.calculatePosition(referenceOffset, referenceRect, target, placement);\n    };\n    Position.prototype.findPosition = function (reference, target, placement, offsetFunction) {\n        if (offsetFunction === void 0) { offsetFunction = this.getAbsoluteOffset.bind(this); }\n        var referenceOffset = offsetFunction(reference);\n        var referenceRect = reference.getBoundingClientRect();\n        return this.calculatePosition(referenceOffset, referenceRect, target, placement);\n    };\n    Position.prototype.findPositionAt = function (offset, target, placement) {\n        return this.calculatePosition(offset, { top: 0, left: 0, height: 0, width: 0 }, target, placement);\n    };\n    /**\n     * Get the dimensions of an element from an AbsolutePosition and a reference element\n     */\n    Position.prototype.getPlacementBox = function (target, position) {\n        var targetBottom = target.offsetHeight + position.top;\n        var targetRight = target.offsetWidth + position.left;\n        return {\n            top: position.top,\n            bottom: targetBottom,\n            left: position.left,\n            right: targetRight\n        };\n    };\n    Position.prototype.addOffset = function (position, top, left) {\n        if (top === void 0) { top = 0; }\n        if (left === void 0) { left = 0; }\n        return Object.assign({}, position, {\n            top: position.top + top,\n            left: position.left + left\n        });\n    };\n    Position.prototype.setElement = function (element, position) {\n        element.style.top = position.top + \"px\";\n        element.style.left = position.left + \"px\";\n    };\n    Position.prototype.findBestPlacement = function (reference, target, placements, containerFunction, positionFunction) {\n        var _this = this;\n        if (containerFunction === void 0) { containerFunction = this.defaultContainerFunction.bind(this); }\n        if (positionFunction === void 0) { positionFunction = this.findPosition.bind(this); }\n        /**\n         * map over the array of placements and weight them based on the percentage of visible area\n         * where visible area is defined as the area not obscured by the window borders\n         */\n        var weightedPlacements = placements.map(function (placement) {\n            var pos = positionFunction(reference, target, placement);\n            var box = _this.getPlacementBox(target, pos);\n            var hiddenHeight = 0;\n            var hiddenWidth = 0;\n            var container = containerFunction();\n            // the element is exceeding from top or bottom of its container\n            if (box.top < container.top) {\n                hiddenHeight = container.top - box.top;\n            }\n            else if (box.bottom > container.height) {\n                hiddenHeight = box.bottom - container.height;\n            }\n            // the element is exceeding from left or right of its container\n            if (box.left < container.left) {\n                hiddenWidth = container.left - box.left;\n            }\n            else if (box.right > container.width) {\n                hiddenWidth = box.right - container.width;\n            }\n            // if one of the hidden dimensions is 0 but the other is > 0\n            // we want to have a positive area, so setting the null one to 1\n            if (hiddenHeight && !hiddenWidth) {\n                hiddenWidth = 1;\n            }\n            else if (hiddenWidth && !hiddenHeight) {\n                hiddenHeight = 1;\n            }\n            var area = target.offsetHeight * target.offsetWidth;\n            var hiddenArea = hiddenHeight * hiddenWidth;\n            // if visibleArea is 0 it means the element is fully outside container bounds\n            // and visiblePercent will then be 0\n            var visibleArea = area - hiddenArea;\n            var visiblePercent = visibleArea / area;\n            return {\n                placement: placement,\n                weight: visiblePercent\n            };\n        });\n        // sort the placements from best to worst\n        weightedPlacements.sort(function (a, b) { return b.weight - a.weight; });\n        // pick the best!\n        return weightedPlacements[0].placement;\n    };\n    Position.prototype.findBestPlacementAt = function (offset, target, placements, containerFunction) {\n        var _this = this;\n        if (containerFunction === void 0) { containerFunction = this.defaultContainerFunction.bind(this); }\n        var positionAt = function (_, target, placement) {\n            return _this.findPositionAt(offset, target, placement);\n        };\n        return this.findBestPlacement(null, target, placements, containerFunction, positionAt);\n    };\n    Position.prototype.defaultContainerFunction = function () {\n        return {\n            // we go with window here, because that's going to be the simple/common case\n            top: 0,\n            left: 0,\n            height: windowRef.innerHeight,\n            width: windowRef.innerWidth\n        };\n    };\n    Position.prototype.calculatePosition = function (referenceOffset, referenceRect, target, placement) {\n        if (this.positions[placement]) {\n            return this.positions[placement](referenceOffset, target, referenceRect);\n        }\n        console.error(\"No function found for placement, defaulting to 0,0\");\n        return { left: 0, top: 0 };\n    };\n    return Position;\n}());\nexport { Position };\nexport var position = new Position();\nexport default Position;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}